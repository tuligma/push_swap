// void	find_best_move_in_b(t_ps_hub *data, t_ps_stack *b, t_ps_cost *cost)
// {
// 	t_list *current;
// 	int	temp_pos_b;

// 	current = b->head;
// 	temp_pos_b = 0;
// 	cost->best_step = INT_MAX;
// 	cost->best_both_step = 0;
// 	while (current != NULL)
// 	{
// 		cost->reverse_a = 0;
// 		cost->reverse_b = 0;
// 		cost->pos_a = find_insert_position(data, data->a, *((int *)current->content));
// 		cost->pos_b = temp_pos_b;
// 		if (b->count - cost->pos_b < cost->pos_b)
// 		{
// 			cost->pos_b = b->count - cost->pos_b;
// 			cost->reverse_b = 1;
// 		}
// 		if (data->a->count - cost->pos_a < cost->pos_a)
// 		{
// 			cost->pos_a = data->a->count - cost->pos_a;
// 			cost->reverse_a = 1;
// 		}
		
// 		if (cost->pos_a + cost->pos_b < cost->best_step)
// 		{
// 			cost->best_step = cost->pos_a + cost->pos_b;
// 			cost->best_pos_a = cost->pos_a;
// 			cost->best_pos_b = cost->pos_b;
// 			cost->best_reverse_a = cost->reverse_a;
// 			cost->best_reverse_b = cost->reverse_b;
// 			if (cost->best_reverse_a == cost->best_reverse_b)
// 			{
// 				if (cost->best_pos_a < cost->best_pos_b)
// 					cost->best_both_step = cost->best_pos_a;
// 				else if (cost->best_pos_b < cost->best_pos_a)
// 					cost->best_both_step = cost->best_pos_b;
// 				else if (cost->best_pos_a = cost->best_pos_b)
// 					cost->best_both_step = cost->best_step;
// 				cost->best_both_reverse = cost->best_reverse_a;
// 			}
// 		}
// 		current = current->next;
// 		temp_pos_b++;
// 	}
// }

// int	simultaneous_rotation(t_ps_hub *data, int count, int reverse)
// {
// 	t_ps_cost *cost;
// 	char	*protocol;
// 	void	(*operation)(t_ps_stack *);
// 	int		x;

// 	if (reverse == 1)
// 	{
// 		protocol = data->protocols->rrr;
// 		operation = reverse_rotate;
// 	}
// 	else
// 	{
// 		protocol = data->protocols->rr;
// 		operation = rotate;
// 	}
// 	cost = data->cost;
// 	x = -1;
// 	while (++x < count)
// 	{
// 		both_protocol(data->a, data->b, operation);
// 		if (add_move(data, protocol) != 0)
// 			return (EPSMAL);
// 		(cost->best_both_step)--;
// 		(cost->best_pos_a)--;
// 		(cost->best_pos_b)--;
// 	}
// 	return (0);
// }

// int	find_which_to_push(t_ps_hub* data, t_ps_stack *b, t_ps_stack *a)
// {
// 	t_ps_cost *cost;
// 	// ft_printf("\nStack A:\n");
// 	// ft_lstiter(data->a->head, print_node);
// 	// ft_printf("\nStack B:\n");
// 	// ft_lstiter(data->b->head, print_node);
// 	// ft_printf("\n");
// 	if (data->cost == NULL && struct_init((void **)&data->cost, sizeof(t_ps_cost)) != 0)
// 		return (EPSMAL);
// 	cost = data->cost;
// 	find_best_move_in_b(data, b, cost);
// 	if (cost->best_both_step > 0)
// 	{
// 		if (simultaneous_rotation(data, data->cost->best_both_step, data->cost->best_both_reverse) != 0)
// 			return (EPSMAL);
// 	}
// 	if (cost->best_pos_a > 0)
// 	{
// 		if (cost->reverse_a == 1)
// 		{
// 			if (rotate_or_reverse_stack_a(data, a, cost->best_pos_a, reverse_rotate) != 0)
// 				return (EPSMAL);
// 		}
// 		else 
// 		{
// 			if (rotate_or_reverse_stack_a(data, a, cost->best_pos_a, rotate) != 0)
// 				return (EPSMAL);
// 		}
// 	}
// 	if (cost->best_pos_b > 0)
// 	{
// 		if (cost->best_reverse_b == 1)
// 		{
// 			if(rotate_or_reverse_stack_a(data, b, cost->best_pos_b, reverse_rotate) != 0)
// 				return (EPSMAL);
// 		}
// 		else
// 		{
// 			if (rotate_or_reverse_stack_a(data, b, cost->best_pos_b, rotate) != 0)
// 				return (EPSMAL);
// 		}
// 	}
// 	push(b, a);
// 	if (add_move(data, data->protocols->pb) != 0)
// 		return (EPSMAL);
// 	// ft_printf("\nStack A:\n");
// 	// ft_lstiter(data->a->head, print_node);
// 	// if (*((int *)a->head->content) == 98)
// 	// {
// 	// 	ft_printf("\nStack B:\n");
// 	// 	ft_lstiter(data->b->head, print_node);
// 	// }
// 	// ft_printf("\n");
// 	if (b->count > 0)
// 		find_which_to_push(data, b, a);
// 	return (0);
// }

void	is_best_move_in_b(t_ps_hub *data, t_list *current, int pos_b)
{
	t_ps_cost *cost;
	int	reverse_a;
	int	reverse_b;
	int	pos_a;
	int	temp_pos_b;

	cost = data->cost;
	reverse_a = 0;
	reverse_b = 0;
	pos_a = find_insert_position(data, data->a, *((int *)current->content));
	temp_pos_b = pos_b;
	if (data->b->count - temp_pos_b < pos_b)
	{
		temp_pos_b = data->b->count - temp_pos_b;
		reverse_b = 1;
	}
	// else
	// 	reverse_b = 0;
	if (data->a->count - pos_a < pos_a)
	{
		pos_a = data->a->count - pos_a;
		reverse_a = 1;
	}
	// else
	// 	reverse_a = 0;
	if (pos_a + temp_pos_b < cost->best_step)
	{
		cost->best_step = pos_a + temp_pos_b;
		cost->pos_a = pos_a;
		cost->pos_b = temp_pos_b;
		cost->reverse_a = reverse_a;
		cost->reverse_b = reverse_b;
	}
}


void	find_best_move_in_b(t_ps_hub *data, t_ps_stack *b, t_ps_cost *cost)
{
	t_list *current;
	int	pos_b;

	current = b->head;
	pos_b = 0;
	cost->best_step = INT_MAX;
	while (current != NULL)
	{
		is_best_move_in_b(data, current, pos_b);
		current = current->next;
		pos_b++;
	}
}


int	insertion_position_max_min(t_list *current, int content, int max, int min)
{
	if (current->next != NULL && (content > max || content < min))
	{
		if (content < *((int *)current->content) && (*((int *)current->content) == max || *((int *)current->next->content) == min))
			return (1);
		else if (content > *((int *)current->content)  && (*((int *)current->content) == max || *((int *)current->next->content) == min))
			return (1);
	}
	return (0);
}

int	insertion_position_inbetween(t_ps_hub *data,
	t_list *current, int content, int max)
{
	if (current->next != NULL&& content == data->max  && *((int *)current->content) == max)
		return (1);
	else if (content == data->min  && *((int *)current->content) == max)
		return (1);
	else if (current->next != NULL && content > *((int *)current->content) && content < *((int *)current->next->content))
			return (1);
	else if (data->a->tail != NULL && current == data->a->tail && content > *((int *)current->content) && content < *((int *)data->a->head->content))
			return (0);
	return (-1);
}

int find_insert_position(t_ps_hub *data, t_ps_stack *a, int content)
{
	t_list *current;
	int	position;
	int	max;
	int	min;
	int	result;

	max = 0;
	min = 0;
	current_min_max(a, &min, &max);
	position = 0;
	current = a->head;
	while (current != NULL)
	{
		if (insertion_position_max_min(current, content, max, min) == 1)
			return (++position);
		result = insertion_position_inbetween(data, current, content, max);
		if (result == -1)
			continue;
		else if (result == 1)
			return (++position);
		else
			return (0);
		current = current->next;
		position++;
	}
	return (position);
}